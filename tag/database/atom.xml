<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: database | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/database/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2014-07-07T11:18:41+01:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simple Database Migrations]]></title>
    <link href="http://edmondscommerce.github.io/php/simple-database-migrations.html"/>
    <updated>2014-04-28T13:22:34+01:00</updated>
    <id>http://edmondscommerce.github.io/php/simple-database-migrations</id>
    <content type="html"><![CDATA[<p>Some times you just need something simple to manage database versions. This few lines of PHP is something I have used on various projects to assist with database versioning.</p>

<p>It is definitely not a fully featured migrations system, there is no downgrade functionality, it is purely for versioning up a DB to the latest version.</p>

<p>Largely how it works is up to you as it is simply a way of requiring PHP files in numerical order.</p>

<p>Here is the code:</p>

<p>``` php
&lt;?php
$res = mysql_fetch_assoc(db_query(&ldquo;select version from db_migrations order by version desc limit 0,1&rdquo;));
$current_version = ($res[&lsquo;version&rsquo;]) ? $res[&lsquo;version&rsquo;] : 0;
$di = new DirectoryIterator(<strong>DIR</strong> . &lsquo;/migrations&rsquo;);
$torun = array();
foreach ($di as $f) {</p>

<pre><code>/* @var $f DirectoryIterator */
if ($f-&gt;isDot()) {
    continue;
}
if ('php' == pathinfo($f-&gt;getFilename(), PATHINFO_EXTENSION)) {
    $exp = explode('.', strval($f));
    if (2 != count($exp)) {
        throw new Exception('#1 Invalid migration file ' . strval($f) . ' in ' . __FILE__);
    }
    $version = $exp[0];
    if (!is_numeric($version)) {
        throw new Exception('#2 Invalid migration file ' . strval($f) . ' in ' . __FILE__);
    }
    if ($version &gt; $current_version) {
        $torun[$version] = strval($f);
    }
} else {
    throw new Exception('#3 Invalid migration file ' . strval($f) . ' in ' . __FILE__);
}
</code></pre>

<p>}</p>

<p>if (!empty($torun)) {</p>

<pre><code>ksort($torun, SORT_NUMERIC);
foreach ($torun as $v =&gt; $t) {
    require(__DIR__ . '/migrations/' . $t);
    h(3, 'Database Migrations - running migration ' . $t);
    db_query("insert into db_migrations set version = '$v' ");
}
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP PDO Fetch Object and Columns with Spaces]]></title>
    <link href="http://edmondscommerce.github.io/php/php-pdo-fetch-object-and-columns-with-spaces.html"/>
    <updated>2013-05-24T17:39:35+01:00</updated>
    <id>http://edmondscommerce.github.io/php/php-pdo-fetch-object-and-columns-with-spaces</id>
    <content type="html"><![CDATA[<p>If you use PDO and Fetch Object, it might not be clear exactly to access row properties that are based on columns that have spaces.</p>

<p>I know I searched for things like:</p>

<p>PDO Columns with spaces
PDO::fetchObject spaces
and PDO spaces in column names</p>

<p>I eventually found what I was looking for in the depths of the PHP.net comments however hopefully this post will be a little bit easier to find thanks to a bit of primitive SEO up there.</p>

<p>The solution to using columns with spaces is simply this:</p>

<p>```php</p>

<p>$sql=&ldquo;select * from table_with_spaces_in_column_names &rdquo;;
$statement = $myPDOObject->prepare($sql);
$statement->execute();
$row = $statement->fetchObject();
$ColumnWithSpaces = $row->{&lsquo;Column With Spaces&rsquo;}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Magento Database Migrations to Track Configuration Changes]]></title>
    <link href="http://edmondscommerce.github.io/magento/using-magento-database-migrations-to-track-configuration-changes.html"/>
    <updated>2013-05-21T09:11:44+01:00</updated>
    <id>http://edmondscommerce.github.io/magento/using-magento-database-migrations-to-track-configuration-changes</id>
    <content type="html"><![CDATA[<p>Often when working on a Magento site, there is a requirement to build custom functionality or implement new themes etc but to finish the job, the final step will be to perform some admin configuration.</p>

<p>This manual step can introduce the possiblity of human error if a step is missed or not performed exactly correctly.</p>

<p>Also if the configuration is to be applied multiple times across staging, pre production and final production then these risks increase.</p>

<p>The only sure way to make sure that the correct configuration is applied and also to provide a proper audit trail for configuration changes is to use Magento&rsquo;s database migrations &ndash; install and upgrade scripts &ndash; to update the database programmatically with the required configuration changes.</p>

<p>To assist with this, there is a nice simple module you can find on Git Hub:</p>

<p><a href="https://github.com/danslo/MigrationHelper"><a href="https://github.com/danslo/MigrationHelper">https://github.com/danslo/MigrationHelper</a></a></p>

<p>This module will automatically create the migration files for you which can be a real time saver.</p>

<p>I would always suggest you create your own custom namespaced configuration migration module that is purely to track these configuration changes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA["Base table or view already exists: 1050 Table ‘*’ already exists" After Deleting Tables]]></title>
    <link href="http://edmondscommerce.github.io/magento/base-table-or-view-already-exists-1050-table-already-exists-after-deleting-tables.html"/>
    <updated>2013-01-08T16:27:02+00:00</updated>
    <id>http://edmondscommerce.github.io/magento/base-table-or-view-already-exists-1050-table-already-exists-after-deleting-tables</id>
    <content type="html"><![CDATA[<p>If for example you&rsquo;re removing an extension and want to clear out its information from the database, you&rsquo;ll need to establish the rows and tables it&rsquo;s inserted, as well as some standard Magento table entries.</p>

<p>So you&rsquo;ve removed everything, cleared your cache and now you go to the homepage to check everything is all good, and boom, PDOException:</p>

<p><code>
Base table or view already exists: 1050 Table ‘*’ already exists
</code></p>

<p>In my case it was <code>salesrule</code>, which made me question why it was trying to create the table afresh. The reason I got this is that I&rsquo;d erroneously removed salesrule_setup from core_resource, and therefore Magento was reinstalling the module. Reinstating the row, and clearing my cache solved the issue</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Establishing a New Database Connection in Magento]]></title>
    <link href="http://edmondscommerce.github.io/magento/establishing-a-new-database-connection-in-magento.html"/>
    <updated>2012-12-10T15:18:27+00:00</updated>
    <id>http://edmondscommerce.github.io/magento/establishing-a-new-database-connection-in-magento</id>
    <content type="html"><![CDATA[<p>Connecting to a new database in <a href="http://edmondscommerce.github.io/platforms/magento">Magento</a> is not the most straight forward of tasks yet it is better structured in other systems that give you no other options. In some systems (such as osCommerce) you would have no choice but to manually create a new PDO object and give it the necessary details.</p>

<p>In Magneto all database connections are defined in the configuration. The connection that you will always have available is &lsquo;default_setup&rsquo; which, by convention, is always defined in app/etc/local.xml.</p>

<p>If you will always want the second database connection available you should consider adding it to app/etc/local.xml. You can also define them in module specific configuration if you desire.</p>

<p>Knowing that the database configuration is nothing more that configuration establishing a new database connection on the fly in code is relatively straight forward. Here is some example code to do this:</p>

<p>```php</p>

<p>&lt;?php
$config = Mage::app()&ndash;>getConfig();</p>

<p>$originalPrefix = &lsquo;global/resources/default_setup&rsquo;;
$newPrefix = &lsquo;global/resources/orders_db&rsquo;;</p>

<p>$nodesToCopy = array(</p>

<pre><code>'/connection/host',
'/connection/username',
'/connection/password',
'/connection/initStatements',
'/connection/model',
'/connection/type',
'/connection/pdoType',
'/connection/active'
</code></pre>

<p>);</p>

<p>foreach($nodesToCopy as $nodeToCopy) {</p>

<pre><code>$nodeVal = (string)$config-&gt;getNode($originalPrefix . $nodeToCopy);
$config-&gt;setNode($newPrefix.$nodeToCopy, $nodeVal);
</code></pre>

<p>}</p>

<p>$config->setNode(&lsquo;global/resources/orders_db/connection/dbname&rsquo;, &lsquo;import_orders&rsquo;);</p>

<p>$ordersDb = Mage::getSingleton(&lsquo;core/resource&rsquo;)&ndash;>getConnection(&lsquo;orders_db&rsquo;);</p>

<p>```</p>

<p>In this example the &lsquo;default_setup&rsquo; connection details are copied to a new connection called &lsquo;orders_db&rsquo;, then the database for this new connection is changed to &lsquo;import_orders&rsquo;. Having defined the configuration for the database simply get the connection object and Magento will establish the connection for you.</p>
]]></content>
  </entry>
  
</feed>
