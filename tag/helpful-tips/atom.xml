<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: helpful tips | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/helpful-tips/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2014-05-14T11:48:19+01:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Automatically convert old PHP file to camelCase ]]></title>
    <link href="http://edmondscommerce.github.io/bash/automatically-convert-old-php-file-to-camelcase.html"/>
    <updated>2013-10-17T10:53:15+01:00</updated>
    <id>http://edmondscommerce.github.io/bash/automatically-convert-old-php-file-to-camelcase</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve recently been working with an old project that uses a combination of different coding styles.</p>

<p>One of the more trivial annoyances with this is that the variables used through the project are a combination of $camelCase and $snake_case which throws of the coding standards tools that I use.</p>

<p>To get round this I have put a little script together that will convert $snake_case to $camelCase automatically.</p>

<p>Obviously, you will need to check the results of this to make sure that there are not variables that should not be changed, but it has saved me a lot of time doing this manually.</p>

<p>I&rsquo;ve added this to my .bash_allias file, though it could easily be turned into a standalone script if required</p>

<p>```bash</p>

<h1>Fix legacy code</h1>

<p> cammelCase() {
   vim -E -s $@ &lt;&lt;-EOF
   :%s#\%($\%(\k+))\@&lt;=_(\k)#\u\1#g
   :update
   :quit
EOF</p>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tab Complete for SSH and SCP]]></title>
    <link href="http://edmondscommerce.github.io/magento/bash/tab-complete-for-ssh-and-scp.html"/>
    <updated>2013-07-26T10:31:41+01:00</updated>
    <id>http://edmondscommerce.github.io/magento/bash/tab-complete-for-ssh-and-scp</id>
    <content type="html"><![CDATA[<p>If you are required to connect to different servers, then remembering and typing in all of the details can become tiresome.</p>

<p>Thankfully there is simple solution to this, using the SSH config file.</p>

<p>To make use of this, create the following file ~/.ssh/config</p>

<p>In there add the following details</p>

<p>```bash</p>

<p>Host easyToRememberName</p>

<pre><code>HostName 127.0.0.1
Port 2020
User ross
</code></pre>

<p>```</p>

<p>You will then can tab completion on ssh and scp commands. You can see more of the options that can be set in the file <a href="http://linux.die.net/man/5/ssh_config" title="ssh config man page">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Magento Category Move Error Exception General error: 1205 + solution]]></title>
    <link href="http://edmondscommerce.github.io/magento/magento-category-move-error-exception-general-error-1205-solution.html"/>
    <updated>2013-04-05T15:44:14+01:00</updated>
    <id>http://edmondscommerce.github.io/magento/magento-category-move-error-exception-general-error-1205-solution</id>
    <content type="html"><![CDATA[<p>There is a problem in Magento that when you try to move a category by dragging it in the admin, it can cause the above error, whilst causing the rest of the site to slow down.</p>

<p>This is caused by the system trying to re-index every product within the space of a transaction.</p>

<p>An easy way to get round this is to switch the indexing mode from auto to manual and then move the categories.</p>

<p>You will still need to re-index the site, but this can be run on a cron when the site is quite.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bash timeout and copying text in vim]]></title>
    <link href="http://edmondscommerce.github.io/bash/bash-timeout-and-copying-text-in-vim.html"/>
    <updated>2013-03-14T12:59:42+00:00</updated>
    <id>http://edmondscommerce.github.io/bash/bash-timeout-and-copying-text-in-vim</id>
    <content type="html"><![CDATA[<p>I have been working with a server that had been configured differently from the way that I prefer.</p>

<p>The two biggest complaints that I had about it were that the timeout was set very low, meaning that the connection would break off every five minutes, and that vim had been set up so if you selected text using the mouse you could not copy it.</p>

<p>The solutions to these two problems are as follows.</p>

<p>You can tell the terminal not to timeout with the following command</p>

<p>```bash</p>

<p>export TMOUT=0</p>

<p>```</p>

<p>Be aware that this will only work for the terminal that you are working with.</p>

<p>The issue with vim is that the mouse was triggering visual mode.</p>

<p>To get round this hold down shift when selecting text and everything will work as expected</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Correct recursive backups in bash]]></title>
    <link href="http://edmondscommerce.github.io/bash/correct-recursive-backups-in-bash.html"/>
    <updated>2013-02-20T20:54:57+00:00</updated>
    <id>http://edmondscommerce.github.io/bash/correct-recursive-backups-in-bash</id>
    <content type="html"><![CDATA[<p>Sometime a backup script can go wrong, and rather the overwrite the old files you place a copy of the new ones into the same folder.</p>

<p>This can then escalate and before you know it you have multiple levels of the same files.</p>

<p>If you just want to flatten these files then this script can do that you</p>

<p>```bash</p>

<p>// The duplicated directory
DUPLICATED_DIR_NAME=&lsquo;uploads&rsquo;
// A new directory for the files to go into
NEW_DIR_NAME=&lsquo;realuploads&rsquo;
for f in <code>find ./ | grep $DUPLICATED_DIR_NAME/$DUPLICATED_DIR_NAME</code>;
do
NEWFILE=<code>echo $f | sed 's/$DUPLICATED_DIR_NAME\//\//g'</code>;
NEWDIR=../$NEW_DIR_NAME/<code>dirname $NEWFILE</code>;
if [[ ! -d $NEWDIR ]]
then
mkdir $NEWDIR;
fi
cp -f &quot;$f&quot; ../$NEW_DIR_NAME/$NEWFILE;
done</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
