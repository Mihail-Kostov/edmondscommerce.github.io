<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: php | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/php/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2014-02-11T10:08:38+00:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Wrapping a List in Quotes in PHPStorm]]></title>
    <link href="http://edmondscommerce.github.io/phpstorm/wrapping-a-list-in-quotes-in-phpstorm.html"/>
    <updated>2013-12-06T11:35:58+00:00</updated>
    <id>http://edmondscommerce.github.io/phpstorm/wrapping-a-list-in-quotes-in-phpstorm</id>
    <content type="html"><![CDATA[<p>Some times you might find your self with a list of values you want to copy and paste from somewhere into your PHP code as an array of strings.</p>

<p>For example, take this list of carrier names that I need to use:</p>

<p><code>
Blue Package, USPS, UPS, UPSMI, FedEx, DHL, DHL Global Mail, Fastway, UPS Mail Innovations, Lasership, Royal Mail, FedEx SmartPost, OSM, OnTrac, Streamlite, Newgistics, Canada Post, City Link, GLS, GO!, Hermes Logistik Gruppe, Parcelforce, TNT, Target, SagawaExpress, NipponExpress, YamatoTransport, Other
</code></p>

<p>I really don&rsquo;t fancy wrapping each element of this list with quotes one by one, there must be a better way!</p>

<p>There is, you can use the regex replace functionality of PHPStorm to do this for you quickly and easily.</p>

<p>First of all paste the string into your PHPStorm editor and highlight it. Then hit <code>[ctrl]+[r]</code> to start your find and replace.</p>

<p>The &ldquo;In Selection&rdquo; tick box should be ticked already, you also need to tick the regex box.</p>

<p>Then in the find section, use this regex:
<code>
( |)([^,]+),
</code></p>

<p>And in your replace box, put this:</p>

<p><code>
\n'$2',
</code></p>

<p>This gets you nearly all the way there, you might just need to tidy up a bit you should now have something looking like this:</p>

<p><code>
'Blue Package',
'USPS',
'UPS',
'UPSMI',
'FedEx',
'DHL',
'DHL Global Mail',
'Fastway',
'UPS Mail Innovations',
'Lasership',
'Royal Mail',
'FedEx SmartPost',
'OSM',
'OnTrac',
'Streamlite',
'Newgistics',
'Canada Post',
'City Link',
'GLS',
'GO!',
'Hermes Logistik Gruppe',
'Parcelforce',
'TNT',
'Target',
'SagawaExpress',
'NipponExpress',
'YamatoTransport', Other
</code></p>

<p>The <code>Other</code> on the end has not been converted has it doesn&rsquo;t have a trailing comma. You could mess about with yoru regex trying to get this to also be converted, or you could say good enough and move on.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automatically convert old PHP file to camelCase ]]></title>
    <link href="http://edmondscommerce.github.io/bash/automatically-convert-old-php-file-to-camelcase.html"/>
    <updated>2013-10-17T10:53:15+01:00</updated>
    <id>http://edmondscommerce.github.io/bash/automatically-convert-old-php-file-to-camelcase</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve recently been working with an old project that uses a combination of different coding styles.</p>

<p>One of the more trivial annoyances with this is that the variables used through the project are a combination of $camelCase and $snake_case which throws of the coding standards tools that I use.</p>

<p>To get round this I have put a little script together that will convert $snake_case to $camelCase automatically.</p>

<p>Obviously, you will need to check the results of this to make sure that there are not variables that should not be changed, but it has saved me a lot of time doing this manually.</p>

<p>I&rsquo;ve added this to my .bash_allias file, though it could easily be turned into a standalone script if required</p>

<p>```bash</p>

<h1>Fix legacy code</h1>

<p> cammelCase() {
   vim -E -s $@ &lt;&lt;-EOF
   :%s#\%($\%(\k+))\@&lt;=_(\k)#\u\1#g
   :update
   :quit
EOF</p>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHPStorm Regex Convert Array to Object Syntax]]></title>
    <link href="http://edmondscommerce.github.io/php/phpstorm-regex-convert-array-to-object-syntax.html"/>
    <updated>2013-08-27T14:40:35+01:00</updated>
    <id>http://edmondscommerce.github.io/php/phpstorm-regex-convert-array-to-object-syntax</id>
    <content type="html"><![CDATA[<p>If you are converting some code from using array syntax to object property syntax then you might like this little snippet of regex.</p>

<p>This is design to paste straight into the find/replace dialogue in PHPStorm</p>

<p>Find:
```</p>

<p>\$(\w+)[&lsquo;([^&rsquo;]+)&lsquo;]</p>

<p>```</p>

<p>Replace:
```</p>

<p>\\$$1->$2</p>

<p>```</p>

<p>And that is it</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP Base64 Decode if Encoded Otherwise Leave Intact]]></title>
    <link href="http://edmondscommerce.github.io/php/php-base64-decode-if-encoded-otherwise-leave-intact.html"/>
    <updated>2013-07-25T15:05:08+01:00</updated>
    <id>http://edmondscommerce.github.io/php/php-base64-decode-if-encoded-otherwise-leave-intact</id>
    <content type="html"><![CDATA[<p>I had a scenario where an API I was working with would sometimes base64 encode data (instead of using CDATA which is the more usual approach).</p>

<p>However to really make things interesting, they didn&rsquo;t always do this so you couldn&rsquo;t just go and decode everything.</p>

<p>Here is the solution I came up with:</p>

<p>First of all, take the raw response and run preg_replace_callback on it to grab all of the XML contents:</p>

<p>```php</p>

<p>preg_replace_callback(&lsquo;%>([^&lt;]+?)&lt;%&rsquo;, array($this, &lsquo;_decode&rsquo;), $response)</p>

<p>```</p>

<p>Then the callback function is a method on the same object hence the use of array($this, &lsquo;_decode&rsquo;)</p>

<p>```php</p>

<pre><code>/**
 * Decode from bas64 if it actually is base64 encoded in the first place
 *
 * If not return the raw string
 *
 * @param $matches
 * @return string
 */
protected function _decode($matches)
{
    $raw=$matches[1];
    $decoded = base64_decode($raw, true);
    $return=$decoded;
    if(false === $decoded){
        $return=$raw;
    }elseif(base64_encode($decoded) != $raw){
        $return=$raw;
    }
    return '&gt;&lt;![CDATA[' . $return . ']]&gt;&lt;';
}
</code></pre>

<p>```</p>

<p>What this method does is first of all try calling decode with the optional strict flag. This makes the function return false if it thinks it isn&rsquo;t base64 encoded. It would be great if this was enough but unfortunately you need to do more.</p>

<p>If it doesn&rsquo;t return false at that stage, we do the real test which is to try encoding it back to base64 and make sure that the rencoded string matches the raw (before original decoding) string. If it was base64 encoded in the first place then this should match.</p>

<p>By doing this we can handle any kind of mixture of base64 encoded and plain text xml string and get it ready for simpleXMl.</p>

<p>Notice I am also wrapping the data in CDATA tags to help avoid XML issues when creating the simpleXml object.</p>

<p>However &ndash; one last trick. The reason they were using base64 encoding is because there was some dodgy non XML friendly characters in there. The solution here (if you don&rsquo;t mind compromising the data a little which I didn&rsquo;t for my purposes) then you can do the following:</p>

<p>```php</p>

<p>//have to utf8 encode it to fix the fact its not properly encoded at their end
$xml = simplexml_load_string(utf8_encode($response));</p>

<p>```</p>

<p>And that&rsquo;s it, another crazy API defeated and bent to my will!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sylius E-Commerce based on Symfony]]></title>
    <link href="http://edmondscommerce.github.io/magento/sylius-e-commerce-based-on-symfony.html"/>
    <updated>2013-07-23T13:48:47+01:00</updated>
    <id>http://edmondscommerce.github.io/magento/sylius-e-commerce-based-on-symfony</id>
    <content type="html"><![CDATA[<p>As if there weren&rsquo;t enough!</p>

<p>There is a new contender for the open source e-commerce crown, a platform called <b><a href="http://sylius.com/features" target="_blank">Sylius</a></b>. The thing that makes this one especially interesting is that rather than being built from scratch it is based upon a very well established PHP framework called Symfony. Some would argue that Symfony is the &ldquo;other&rdquo; PHP framework alongside Zend Framework. In fact there are many frameworks however it would be fair to say that Symfony and Zend Framework are the most well established and up to date.</p>

<p>Basing an e-commerce platform upon an existing PHP framework has many advantages including transferrable skills, established best practice structure and also easier access to a wide range of functionality via library components and extensions.</p>

<p>There is another e-commerce platform based upon a PHP framework. It is based upon Zend Framework &ndash; you might have heard of it &ndash; Magento.</p>

<p>It does look very much like Sylius is still quite a new offering and it can not boast the level of maturity and establishment that Magento has achieved. That said, things move quickly in this industry and who knows what will be top dog in the next five years.</p>

<p>If you are considering Sylius for your e-commerce website and would like to find a UK Sylius developer to work with then do get in touch with Edmonds Commerce today.</p>
]]></content>
  </entry>
  
</feed>
