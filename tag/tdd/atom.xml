<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: tdd | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/tdd/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2015-02-03T12:50:33+00:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Multiple Behat and Mink profiles for testing multiple browsers]]></title>
    <link href="http://edmondscommerce.github.io/Behat/multiple-behat-and-mink-profiles-for-testing-multiple-browsers.html"/>
    <updated>2015-02-03T12:20:36+00:00</updated>
    <id>http://edmondscommerce.github.io/Behat/multiple-behat-and-mink-profiles-for-testing-multiple-browsers</id>
    <content type="html"><![CDATA[<p>Behat makes it easy to write and run automated testing in browser and in most cases where functionality is not javascript driven then testing in a single browser is fine.</p>

<p>However if you are testing Javascript driven functionality then it is best to have multiple profiles for multiple browsers without having to write the scenario multiple times with different tagsi for different sessions. Luckily behat support defination of multiple profiles which inherit from a single default profile for all your browser needs. You simply need to set up your bhat yaml config file like so:
``` yaml
default:
  extensions:</p>

<pre><code>Behat\MinkExtension: 
  base_url: "http://someurl.com"
  default_session: selenium_firefox_session
  goutte: ~
  sessions: 
    goutte_session: 
      goutte: 
        guzzle_parameters: 
          ssl.certificate_authority: false
    selenium_chrome_session: 
      selenium2: 
        browser: chrome
    selenium_firefox_session: 
      selenium2: 
        browser: firefox
</code></pre>

<p>  suites:</p>

<pre><code>my_suite: 
  contexts: 
    - FeatureContext
    - Behat\MinkExtension\Context\MinkContext
</code></pre>

<p>chrome:
  extensions:</p>

<pre><code>Behat\MinkExtension: 
  default_session: selenium_chrome_session
</code></pre>

<p>firefox:
  extensions:</p>

<pre><code>Behat\MinkExtension: 
  default_session: selenium_firefox_session
</code></pre>

<p>```</p>

<p>The to run the crome profile for example use the -p option flag on the behat command as show:
<code>bash
bin/behat -p chrome
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Faker Symfony2 Integration]]></title>
    <link href="http://edmondscommerce.github.io/symfony2/faker-symfony2-integration.html"/>
    <updated>2013-12-02T20:43:49+00:00</updated>
    <id>http://edmondscommerce.github.io/symfony2/faker-symfony2-integration</id>
    <content type="html"><![CDATA[<p>Generating test data is a crucial part of properly testing your code. If you have to hard code your test data or fixtures then you might be tempted to use only a small number of test entities.</p>

<p>To help with this you can use the brilliant <a href="https://github.com/fzaninotto/Faker">Faker</a> library to generate your test data. The Faker library is designed purely to generate test data and has a range of providers for all kinds of data.</p>

<p>As if that wasn&rsquo;t good enough, you can leverage all the power of this library in your Symfony2 development by simply installing this Symfony2 bundle, <a href="https://github.com/willdurand/BazingaFakerBundle/blob/master/Resources/doc/index.md">BazingaFakerBundle</a>.</p>

<p>Installation is a breeze with Composer and then simply reference your entities in the configuration and run the command</p>

<p><code>
app/console faker:populate
</code></p>

<p>To generate your entities programmatically rather than as a command line action (perhaps as part of a unit or functional test) you can use this code:</p>

<p>``` php
//Faker load test data
$populator = $this->getContainer()&ndash;>get(&lsquo;faker.populator&rsquo;);
$insertedPks = $populator->execute();
foreach ($insertedPks as $class => $pks) {</p>

<pre><code>$reflClass = new \ReflectionClass($class);
$shortClassName = $reflClass-&gt;getShortName();
printf("\nFaker: Inserted %s new %s objects\n", count($pks), $shortClassName);
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
