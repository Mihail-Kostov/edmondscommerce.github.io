<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: index | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/index/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2013-11-28T13:20:54+00:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fast E-Commerce Search Solution]]></title>
    <link href="http://edmondscommerce.github.io/fast-e-commerce-search-solution.html"/>
    <updated>2013-04-29T10:59:11+01:00</updated>
    <id>http://edmondscommerce.github.io/fast-e-commerce-search-solution</id>
    <content type="html"><![CDATA[<p>One of the trickiest parts of any e-commerce store to get running quickly is the search results. The problem is compounded for large or complex stores where a database query based search for a multi word search phrase can become a real behemoth of a database query that has to search for each word in a multitude of database tables and columns. Then throw in other issues such as table locking and the performance issues can start to hurt the site as a whole.</p>

<h3>Caching for Performance</h3>


<p>One common solution to scaling up e-commerce stores is to use a variety of methods and levels of caching, from a database query cache right up to a full page caching system perhaps powered by Varnish. This solution works well for product and category pages for which there is a finite number. When it comes to search results pages though, each possible search phrase is a completely separate set of pages. You might be able to keep a warm cache for your most popular search phrases but anything else will be raw results. It will show your server at its worst performance.</p>

<h3>Alternative Enterprise Search Engine</h3>


<p>In this scenario it is time to start looking at other search solutions. If you want a turnkey professional solution then check out Google Commerce Search. This premium offering gives you a powerful search engine that is entirely outsourced and uses Google technology to deliver great quality results. As you can probably imagine though, this premium product comes with a premium and enduringly high subscription fee.</p>

<h3>Enterprise Open Source</h3>


<p>Instead what we are now recommending to our larger clients is to look at implementing the Solr search engine. <a href="http://lucene.apache.org/solr/" target="_blank">Apache Solr</a> is an enterprise level search engine. It is used in a wide variety of impressive sites &ndash; <a href="http://wiki.apache.org/solr/PublicServers" target="_blank">you can see a list here</a>. Names like Netflix, The Guardian and eBay really underline the fact that this is serious and powerful technology.</p>

<h3>Advanced Search Functionality</h3>


<p>The great thing is that it is also pretty easy to set up and get running. To get a basic search engine working is no more than a few hours of work. There are many possibilities with the search engine including spelling suggestions, parametric (faceted in Solr speak) search, synoyms, auto suggest and loads more. Depending on exactly how you want this to work will determine exactly how much work is involved.</p>

<p>Solr provides a huge amount of configurability and tuning. For this reason we would always expect a new install of Solr to be followed up with a bit of tweaking to make sure you are getting the right results. Once the right configuration has been determined we can then expect the engine to work tirelessly, serving up lightning fast and excellent quality results without any further investment from your business.</p>

<h3>Implement Solr Search Today</h3>


<p>If you would like your site to be fitted out with a Solr based search system by a professional UK based e-commerce web development agency then get in touch with Edmonds Commerce today. Simply fill out the form below and we will be in touch to discuss how we can take your web site search functionality to the next level.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Magento Flush Everything Cache, Index, Images, JS, CSS in One Go]]></title>
    <link href="http://edmondscommerce.github.io/magento/magento-flush-everything-cache-index-images-js-css-in-one-go.html"/>
    <updated>2012-03-03T16:26:59+00:00</updated>
    <id>http://edmondscommerce.github.io/magento/magento-flush-everything-cache-index-images-js-css-in-one-go</id>
    <content type="html"><![CDATA[<p>If you are developing a Magento store and you would like a method you can call to completely clear everything out that might be cached or indexed etc then you will like this little snippet:</p>

<p>```php</p>

<p>public function flushEverything() {</p>

<pre><code>    Mage::app()-&gt;getCacheInstance()-&gt;flush();
    Mage::getModel('core/design_package')-&gt;cleanMergedJsCss();
    Mage::getModel('catalog/product_image')-&gt;clearCache();
    $indexer    = Mage::getSingleton('index/indexer');
    /* @var $indexer Mage_Index_Model_Indexer */
    foreach($indexer-&gt;getProcessesCollection() as $process){
          $process-&gt;reindexEverything();
    }  
}
</code></pre>

<p>```</p>

<p>This flushes the cache storage, removes merged JS/CSS files, flushes the product image cache then loops through each index and reindexes.</p>

<p>Perhaps overkill but sometimes there&rsquo;s nothing like the use of excessive force!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP Arrays Maintain Index After Removing Exsisting]]></title>
    <link href="http://edmondscommerce.github.io/php/php-arrays-maintain-index-after-removing-exsisting.html"/>
    <updated>2012-02-22T14:57:41+00:00</updated>
    <id>http://edmondscommerce.github.io/php/php-arrays-maintain-index-after-removing-exsisting</id>
    <content type="html"><![CDATA[<p>One of the features that makes PHP such a powerful language is it&rsquo;s arrays. They allow for really complex data structures to be stored and worked on really easy. One interesting aspect of them is that they maintain there index if emptied one element at a time.</p>

<p>Taken from php.net: <a href="http://php.net/manual/en/language.types.array.php"><a href="http://php.net/manual/en/language.types.array.php">http://php.net/manual/en/language.types.array.php</a></a></p>

<p>```php</p>

<p>&lt;?php
// Create a simple array.
$array = array(1, 2, 3, 4, 5);
print_r($array);</p>

<p>// Now delete every item, but leave the array itself intact:
foreach ($array as $i => $value) {</p>

<pre><code>unset($array[$i]);
</code></pre>

<p>}
print_r($array);</p>

<p>// Append an item (note that the new key is 5, instead of 0).
$array[] = 6;
print_r($array);</p>

<p>// Re-index:
$array = array_values($array);
$array[] = 7;
print_r($array);
?></p>

<p>```</p>

<p>Will output:
```
Array
(</p>

<pre><code>[0] =&gt; 1
[1] =&gt; 2
[2] =&gt; 3
[3] =&gt; 4
[4] =&gt; 5
</code></pre>

<p>)
Array
(
)
Array
(</p>

<pre><code>[5] =&gt; 6
</code></pre>

<p>)
Array
(</p>

<pre><code>[0] =&gt; 6
[1] =&gt; 7
</code></pre>

<p>)</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refresh all magento indexes]]></title>
    <link href="http://edmondscommerce.github.io/magento/refresh-all-magento-indexes.html"/>
    <updated>2011-06-17T15:10:02+01:00</updated>
    <id>http://edmondscommerce.github.io/magento/refresh-all-magento-indexes</id>
    <content type="html"><![CDATA[<div class="oldpost"><h4>This is an old post. The information it contains is probably out of date or innacurate</h4>
<p>
This is a post that was written a long time ago and is only being kept here for posterity.
You should probably look up more recent blog posts related to the subject you are researching
</p>
</div>


<p>The indexes for your Magento site should be refreshed on a regular basis. To help you do this you can put the below code in a PHP file in the root of your web site and setup a scheduled task to call it periodically.</p>

<p>```php</p>

<p>require_once &lsquo;app/Mage.php&rsquo;;
$app = Mage::app(&lsquo;admin&rsquo;);
umask(0);
for ($i = 1; $i &lt;= 8; $i++) {</p>

<pre><code>$process = Mage::getModel('index/process')-&gt;load($i);
$process-&gt;reindexAll();
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
