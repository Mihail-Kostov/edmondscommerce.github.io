<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: deployment | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/deployment/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2014-10-03T12:36:28+01:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simple Database Migrations]]></title>
    <link href="http://edmondscommerce.github.io/php/simple-database-migrations.html"/>
    <updated>2014-04-28T13:22:34+01:00</updated>
    <id>http://edmondscommerce.github.io/php/simple-database-migrations</id>
    <content type="html"><![CDATA[<p>Some times you just need something simple to manage database versions. This few lines of PHP is something I have used on various projects to assist with database versioning.</p>

<p>It is definitely not a fully featured migrations system, there is no downgrade functionality, it is purely for versioning up a DB to the latest version.</p>

<p>Largely how it works is up to you as it is simply a way of requiring PHP files in numerical order.</p>

<p>Here is the code:</p>

<p>``` php
&lt;?php
$res = mysql_fetch_assoc(db_query(&ldquo;select version from db_migrations order by version desc limit 0,1&rdquo;));
$current_version = ($res[&lsquo;version&rsquo;]) ? $res[&lsquo;version&rsquo;] : 0;
$di = new DirectoryIterator(<strong>DIR</strong> . &lsquo;/migrations&rsquo;);
$torun = array();
foreach ($di as $f) {</p>

<pre><code>/* @var $f DirectoryIterator */
if ($f-&gt;isDot()) {
    continue;
}
if ('php' == pathinfo($f-&gt;getFilename(), PATHINFO_EXTENSION)) {
    $exp = explode('.', strval($f));
    if (2 != count($exp)) {
        throw new Exception('#1 Invalid migration file ' . strval($f) . ' in ' . __FILE__);
    }
    $version = $exp[0];
    if (!is_numeric($version)) {
        throw new Exception('#2 Invalid migration file ' . strval($f) . ' in ' . __FILE__);
    }
    if ($version &gt; $current_version) {
        $torun[$version] = strval($f);
    }
} else {
    throw new Exception('#3 Invalid migration file ' . strval($f) . ' in ' . __FILE__);
}
</code></pre>

<p>}</p>

<p>if (!empty($torun)) {</p>

<pre><code>ksort($torun, SORT_NUMERIC);
foreach ($torun as $v =&gt; $t) {
    require(__DIR__ . '/migrations/' . $t);
    h(3, 'Database Migrations - running migration ' . $t);
    db_query("insert into db_migrations set version = '$v' ");
}
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Magento Database Migrations to Track Configuration Changes]]></title>
    <link href="http://edmondscommerce.github.io/magento/using-magento-database-migrations-to-track-configuration-changes.html"/>
    <updated>2013-05-21T09:11:44+01:00</updated>
    <id>http://edmondscommerce.github.io/magento/using-magento-database-migrations-to-track-configuration-changes</id>
    <content type="html"><![CDATA[<p>Often when working on a Magento site, there is a requirement to build custom functionality or implement new themes etc but to finish the job, the final step will be to perform some admin configuration.</p>

<p>This manual step can introduce the possiblity of human error if a step is missed or not performed exactly correctly.</p>

<p>Also if the configuration is to be applied multiple times across staging, pre production and final production then these risks increase.</p>

<p>The only sure way to make sure that the correct configuration is applied and also to provide a proper audit trail for configuration changes is to use Magento&rsquo;s database migrations &ndash; install and upgrade scripts &ndash; to update the database programmatically with the required configuration changes.</p>

<p>To assist with this, there is a nice simple module you can find on Git Hub:</p>

<p><a href="https://github.com/danslo/MigrationHelper"><a href="https://github.com/danslo/MigrationHelper">https://github.com/danslo/MigrationHelper</a></a></p>

<p>This module will automatically create the migration files for you which can be a real time saver.</p>

<p>I would always suggest you create your own custom namespaced configuration migration module that is purely to track these configuration changes.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Amazon Web Services Blog: AWS Elastic Beanstalk - Build PHP Apps Using Git-Based Deployment]]></title>
    <link href="http://edmondscommerce.github.io/hosting/amazon-web-services-blog-aws-elastic-beanstalk-build-php-apps-using-git-based-deployment.html"/>
    <updated>2012-03-21T07:44:15+00:00</updated>
    <id>http://edmondscommerce.github.io/hosting/amazon-web-services-blog-aws-elastic-beanstalk-build-php-apps-using-git-based-deployment</id>
    <content type="html"><![CDATA[<p>Easily deploy PHP applications to the Amazon Web Services infrastructure allowing you to take advantage of an easily scaled flexible cloud based system.</p>

<p>Furthermore there is Git based deployment so your version control workflow can hook directly into deployment for speed and convenience.</p>

<p>This does really look attractive. The Angry birds store recently launched on Magento using Varnish and Amazon Web Services and it runs very fast indeed. Perhaps the days of expensive dedicated hardware are really numbered. If its this easy to set something up that can perform as well as a complex server cluster at a fraction of the cost.</p>

<p><a href="http://aws.typepad.com/aws/2012/03/aws-elastic-beanstalk-build-php-apps-using-git-based-deployment.html"><a href="http://aws.typepad.com/aws/2012/03/aws-elastic-beanstalk-build-php-apps-using-git-based-deployment.html">http://aws.typepad.com/aws/2012/03/aws-elastic-beanstalk-build-php-apps-using-git-based-deployment.html</a></a></p>
]]></content>
  </entry>
  
</feed>
