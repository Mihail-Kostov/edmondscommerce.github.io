<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: flush | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/flush/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2014-07-30T17:56:56+01:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Magento Flush Everything Cache, Index, Images, JS, CSS in One Go]]></title>
    <link href="http://edmondscommerce.github.io/magento/magento-flush-everything-cache-index-images-js-css-in-one-go.html"/>
    <updated>2012-03-03T16:26:59+00:00</updated>
    <id>http://edmondscommerce.github.io/magento/magento-flush-everything-cache-index-images-js-css-in-one-go</id>
    <content type="html"><![CDATA[<p>If you are developing a Magento store and you would like a method you can call to completely clear everything out that might be cached or indexed etc then you will like this little snippet:</p>

<p>```php</p>

<p>public function flushEverything() {</p>

<pre><code>    Mage::app()-&gt;getCacheInstance()-&gt;flush();
    Mage::getModel('core/design_package')-&gt;cleanMergedJsCss();
    Mage::getModel('catalog/product_image')-&gt;clearCache();
    $indexer    = Mage::getSingleton('index/indexer');
    /* @var $indexer Mage_Index_Model_Indexer */
    foreach($indexer-&gt;getProcessesCollection() as $process){
          $process-&gt;reindexEverything();
    }  
}
</code></pre>

<p>```</p>

<p>This flushes the cache storage, removes merged JS/CSS files, flushes the product image cache then loops through each index and reindexes.</p>

<p>Perhaps overkill but sometimes there&rsquo;s nothing like the use of excessive force!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flushing Zend Framework]]></title>
    <link href="http://edmondscommerce.github.io/zend%20framework/flushing-zend-framework.html"/>
    <updated>2009-04-28T13:56:31+01:00</updated>
    <id>http://edmondscommerce.github.io/zend%20framework/flushing-zend-framework</id>
    <content type="html"><![CDATA[<div class="oldpost"><h4>This is post is now quite old and the the information it contains may be out of date or innacurate.</h4>
<p>
If you find any errors or have any suggestions to update the information <a href="http://edmondscommerce.github.io/contact-us/index.html">please let us know</a>
or <a href="https://github.com/edmondscommerce/edmondscommerce.github.io">create a pull request on GitHub</a>
</p>
</div>


<p>I have recently been messing around trying to figure out the best way of running long processes within a Zend Framework App.</p>

<p>Usually I would code in regular flush(); commands to make sure that the browser didnt time out and also that the user can see that something is happening.</p>

<p>However, the standard MVC structure of the default ZF application system wraps the entire response in an output buffer which is only flushed once everything is done. This has lots of advantages including allowing to add extra headers (FirePHP) on the fly throughout the application process.</p>

<p>For long running scripts though, it is important for me to flush output. My solution to this is twofold.</p>

<p>Firstly set up an &lsquo;output&rsquo; action in my base controller. The output action is looking for an &lsquo;act&rsquo; parameter in its view script. This act param is then used to generate a url string based on the current controller and the action as the act param. This url string is then used to create an iframe which will be used to output the flushing results of the long running script.</p>

<p>For the long running script action itself, I am going to disable layout and also disable view render. Its really important to switch both of these off.</p>

<p>The following needs to be declared at the top of any action that you intend to be viewed via the output iframe.
```php</p>

<pre><code>// accessed via output action
public function longrunningAction(){
    $this-&gt;_helper-&gt;layout-&gt;disableLayout();
    $this-&gt;_helper-&gt;viewRenderer-&gt;setNoRender(true);
    $this-&gt;_model-&gt;grabImages();
}
</code></pre>

<p>```</p>

<p>Now I am free to echo out basic HTML and also call flush from within my model. To flush the output you need to call both ob_flush() and then flush(). To make this easier I set up a static method in my static Tools class</p>

<p>```php</p>

<pre><code>public static function flush(){
    ob_flush();
    flush();
}
</code></pre>

<p>```</p>

<p>One issue I have had though is that any time the ZF internals try to add a header, you will get a basically meaningless exception telling you that headers have already been sent. It doesn&rsquo;t tell you what header was attempted to be added or why, so you can be left out in the cold a bit when trying to debug.</p>

<p>If anyone knows a good workaround for this, or can offer a better solution for handling these long running processes I would love to hear about it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP Execution After Client Disconnection]]></title>
    <link href="http://edmondscommerce.github.io/php/php-execution-after-client-disconnection.html"/>
    <updated>2009-01-29T12:37:49+00:00</updated>
    <id>http://edmondscommerce.github.io/php/php-execution-after-client-disconnection</id>
    <content type="html"><![CDATA[<div class="oldpost"><h4>This is post is now quite old and the the information it contains may be out of date or innacurate.</h4>
<p>
If you find any errors or have any suggestions to update the information <a href="http://edmondscommerce.github.io/contact-us/index.html">please let us know</a>
or <a href="https://github.com/edmondscommerce/edmondscommerce.github.io">create a pull request on GitHub</a>
</p>
</div>


<p>After a bunch of digging around and some help from the nice people on the #php channel on freenode IRC, I have cleared up the issue regarding PHP script execution and client connection.</p>

<p>If a client disconnects (closes the browser window / tab) and PHP subsequently tries to send information to the client but fails, the script stops executing.</p>

<p>Echoing does not necessarily mean sending information as PHP uses an output buffer. If you use the flush() function though you can force the buffer to be flushed to the client.</p>

<p>If you want to be sure a script will continue to execute when a client has disconnected, you can use the ignore_user_abort() function which will do exactly that.</p>

<p>Problem Solved :&ndash;)</p>
]]></content>
  </entry>
  
</feed>
