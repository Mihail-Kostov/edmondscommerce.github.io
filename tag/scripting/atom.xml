<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: scripting | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/scripting/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2013-12-05T12:25:08+00:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux Bash Scripting: Force Screen if not Cron Task]]></title>
    <link href="http://edmondscommerce.github.io/linux/linux-bash-scripting-force-screen-if-not-cron-task.html"/>
    <updated>2012-08-30T09:27:16+01:00</updated>
    <id>http://edmondscommerce.github.io/linux/linux-bash-scripting-force-screen-if-not-cron-task</id>
    <content type="html"><![CDATA[<p>If you have a long running script that is designed to run as cron but may be run manually from the terminal then you may want to enforce screen so that the process can&rsquo;t be aborted by the SSH terminal being closed for whatever reason.</p>

<p>We already blogged about how to <a href="http://www.edmondscommerce.co.uk/linux/force-a-bash-script-to-run-in-screen/" title="Linux Force Screen">force running as screen here</a>.</p>

<p>This is an extension of this that also checks for running as Cron and if so, does not force screen.</p>

<p>```bash</p>

<h1>First off, ensure running from Cron and if not, Screen</h1>

<p>if [ -t 1 ]
then</p>

<pre><code>echo &amp;quot;Not running as Cron Task&amp;quot;
if [ -n &amp;quot;$STY&amp;quot; ];
then
    echo 'We are inside screen, good';
else
    echo &amp;quot;Not in a screen, please run with screen&amp;quot;
    echo &amp;quot;Exiting&amp;quot;
    exit 1
fi
</code></pre>

<p>else</p>

<pre><code>echo &amp;quot;Running as Cron Task&amp;quot;
</code></pre>

<p>fi</p>

<p>```</p>

<p>Simply paste this somewhere close to the top of your script before it does anything and this will work nicely.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Javascript User Scripting for Android - OnX]]></title>
    <link href="http://edmondscommerce.github.io/android/javascript-user-scripting-for-android-onx.html"/>
    <updated>2012-06-18T13:34:58+01:00</updated>
    <id>http://edmondscommerce.github.io/android/javascript-user-scripting-for-android-onx</id>
    <content type="html"><![CDATA[<p>Just came across this interesting site:</p>

<p><a href="https://www.onx.ms/#recipesPage"><a href="https://www.onx.ms/#recipesPage">https://www.onx.ms/#recipesPage</a></a></p>

<p>It seems to be a very nice system for really customising your Android experience.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging Programmatically Opened Terminals in Gnome]]></title>
    <link href="http://edmondscommerce.github.io/linux/debugging-programmatically-opened-terminals-in-gnome.html"/>
    <updated>2011-11-30T13:59:21+00:00</updated>
    <id>http://edmondscommerce.github.io/linux/debugging-programmatically-opened-terminals-in-gnome</id>
    <content type="html"><![CDATA[<div class="oldpost"><h4>This is an old post. The information it contains is probably out of date or innacurate</h4>
<p>
This is a post that was written a long time ago and is only being kept here for posterity.
You should probably look up more recent blog posts related to the subject you are researching
</p>
</div>


<p>If you are building something that is opening a terminal, perhaps a fancy URL handler or something similar but there are errors causing the terminal to instantly close, then this is the solution for you.</p>

<p>It&rsquo;s actually really simple!</p>

<p>Create a new profile</p>

<p>Select the &ldquo;Title and Command&rdquo; tab</p>

<p>at the bottom there is an option &ldquo;when command exits&rdquo;</p>

<p>You can switch this to &ldquo;Hold Terminal Open&rdquo; which will keep the terminal open so you can see the error message and then fix it</p>

<p>You need to add the following flag to your gnome-terminal launcher:</p>

<p>```</p>

<p>gnome_terminal &mdash;window-with-profile={profile_name}</p>

<p>```</p>

<p>Beautiful!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building Bash function libraries]]></title>
    <link href="http://edmondscommerce.github.io/programming/linux/ubuntu/building-bash-function-libraries.html"/>
    <updated>2011-05-27T10:04:15+01:00</updated>
    <id>http://edmondscommerce.github.io/programming/linux/ubuntu/building-bash-function-libraries</id>
    <content type="html"><![CDATA[<div class="oldpost"><h4>This is an old post. The information it contains is probably out of date or innacurate</h4>
<p>
This is a post that was written a long time ago and is only being kept here for posterity.
You should probably look up more recent blog posts related to the subject you are researching
</p>
</div>


<p>Bash provides many powerful functions but how can you use these easily?</p>

<p>If you spend any time using the command line, either to manage a server or on the desktop, you have to quickly become proficient with bash. You will also find the you carry out many of the same tasks time after time.</p>

<p>This can quickly become tiresome and error prone, particularly if you are piping several commands together. However, bash provides several ways to make your life easier.</p>

<h3>Aliases</h3>


<p>If you are always going to be using the same flags with a command, you can ensure that they are called by default by using an alias.</p>

<p>An alias is a shorthand that bash uses in order to fire commands. Several are included as standard with Ubuntu (and other distros) and are stored in your .bashrc file. You can edit these and add your own as the need occurs.</p>

<p>An example of this is that I prefer the human readable file sizes when using ls. You can turn these on using the -h flag, but you have to include this every time you run the command. To make things easier I changed the alias for ll (long list) to read as follows</p>

<p>```</p>

<p>alias ll=&ldquo;ls -ahlF&rdquo;</p>

<p>```</p>

<p>This way I don&rsquo;t need to remember to put the flag in.</p>

<p>As you build up more of these commands, it makes sense to store them in a separate file so you can easily find and edit them. You can place all of you aliases in a file called .bash_aliases and they will be available for use.</p>

<h3>Scripts</h3>


<p>Aliases are fine for quickly calling simple commands, but many times you will need to carry out more complex tasks. In order to do this, you can make a script, and then call that.</p>

<p>By placing everything into a script, you benefit from being able to carry out more complicated functions, and the easy of calling it from a single command.</p>

<p>An example of this would be if you wanted to compare two branches in git, and see all of the files that had been created or modified, but not the files that had been deleted. You create a file called git_get_changed_files and put the following in</p>

<p>```</p>

<h1>!/bin/bash</h1>

<p>local ORIGINAL CHANGED FILES
ORIGINAL=&ldquo;$1&rdquo;
CHANGED=&ldquo;$2&rdquo;</p>

<pre><code>FILES=$(git diff --name-status $ORIGINAL..$CHANGED public/ | awk '{print $1"@@@@@"$2}')
for FILE in $FILES
do
        echo "$FILE" | awk -F "@@@@@" '{ i=""; if ($1 != "D") print $2}'
done
</code></pre>

<p>```</p>

<p>If you place this in your home/bin folder you will then be able to run  git_get_changed_files like a normal command.</p>

<h3>A Global Function Library</h3>


<p>You can expand on this by creating a global library of functions. This works by putting all of the functions into a folder, where each file is a namespace for different functions.</p>

<p>This can be achieved by creating a script that will source of all of the files in a folder, like so:</p>

<p>```</p>

<h1>!/bin/bash</h1>

<p>for f in $(ls /path/to/folder/);</p>

<pre><code>do source /path/to/folder/$f; 
</code></pre>

<p>done</p>

<p>```</p>

<p>Call this script func and place it in your home/bin folder. Then you put a script in the folder referenced in the file and use the following structure.</p>

<p>```</p>

<p>function parse.(){ # auto complete helper, second argument is a grep against the function list</p>

<pre><code>if [[ '' == "$@" ]]
then
    echo "Parse Namespaced Functions List"
    cat $BASH_SOURCE | grep "^function[^(]" | awk '{j=" USAGE:"; for (i=5; i&lt;=NF; i++) j=j" "$i; print $2" "j}'
else
    echo "Parse Functions Matching: $@"
    cat $BASH_SOURCE | grep "^function[^(]" | awk '{j=" USAGE:"; for (i=5; i&lt;=NF; i++) j=j" "$i; print $2" "j}' | grep $@
fi
</code></pre>

<p>}</p>

<p>function parse.access_log_top_ten_code() { # Show the top ten code from access_log: useage &hellip;code $FILE $CODE</p>

<pre><code>FILE=$1
CODE=$2
echo "Count the top ten $CODE'd pages"

cat $FILE | awk '{ i=($9=="$CODE" ) ? $7 : ""; print i; }' | sort | uniq -c | sort -n | tail -n 11 | head -n 10
</code></pre>

<p>}</p>

<p>```</p>

<p>In this folder a namespace of parse is created. Running
```</p>

<p>func parse.</p>

<p>```</p>

<p>Will list all of the function in the file. Running func parse. log will list all of the function that contain log in the function name or description. When the files are listed, the function name will be displayed with the comment along side it.</p>

<p>As the func command sources all of the different files, you are able to makes use of the functions across different namespaces. This means that you can create a file that will format output and then use that in with your git functions.</p>

<p>I hope that you are able to make use of this idea, and build your own library of functions. Anything that you thing would be useful to add to the library, please mention below.</p>
]]></content>
  </entry>
  
</feed>
