<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: testing | Edmonds Commerce Dev Blog]]></title>
  <link href="http://edmondscommerce.github.io/tag/testing/atom.xml" rel="self"/>
  <link href="http://edmondscommerce.github.io/"/>
  <updated>2015-04-01T12:08:44+01:00</updated>
  <id>http://edmondscommerce.github.io/</id>
  <author>
    <name><![CDATA[EdmondsCommerce Development Team]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Behat]]></title>
    <link href="http://edmondscommerce.github.io/behat/behat.html"/>
    <updated>2015-04-01T12:04:12+01:00</updated>
    <id>http://edmondscommerce.github.io/behat/behat</id>
    <content type="html"><![CDATA[<p>I love Behat. One of the great things about it is that it has been built to be very extensible, so if it doesn&rsquo;t do exactly what you need then it&rsquo;s really quite easy to to customise the way it works without having to do any hacking on the core code. This is because it makes extensive use of an Observer Pattern like Hooks system.</p>

<p>If you want to have your Behat tests fail as soon as a scenario fails &ndash; ideal when you are running a large suite of tests and trying to fix issues &ndash; then simply add in this method into a Context class.</p>

<p>``` php</p>

<pre><code>/** @AfterScenario */
public function dieOnFailedScenario(Behat\Behat\Hook\Scope\AfterScenarioScope $scope)
{
    if (99 === $scope-&gt;getTestResult()-&gt;getResultCode()) {
        if (isset($_SERVER['BEHAT_DIE_ON_FAILURE'])) {
            die("\n\nBEHAT_DIE_ON_FAILURE is defined\n\nKilling Full Process\n\n\n\n");
        } else {
            echo "\n\nTo die on failure, please run:\nexport BEHAT_DIE_ON_FAILURE=true;\n\n";
        }
    }
}
</code></pre>

<p>```</p>

<p>Then in your terminal, simply export BEHAT_DIE_ON_FAILURE=true and then the next time you run your tests, the process will die and you can go and fix the problems.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Behat and emulating mobile browsers using chrome]]></title>
    <link href="http://edmondscommerce.github.io/Behat/behat-and-emulating-mobile-browsers-using-chrome.html"/>
    <updated>2015-02-03T13:00:25+00:00</updated>
    <id>http://edmondscommerce.github.io/Behat/behat-and-emulating-mobile-browsers-using-chrome</id>
    <content type="html"><![CDATA[<p>Lets admit it not all mobile sites are responsive as they were created when responsive sites were in their infancy or just did not exist. Along with that and even if a site is responsive some elements, images, styles and javascript maybe exclusive to mobile user agents or excluded all together due to file size concerns.</p>

<p>It would be useful to test a site when it is dealing with a mobile user agent. However you don not always need a actual mobile browser thanks to chromes mobile device emulation. Although it is not useful it can at lest be used to do some testing when site responds to specific user agents. Chromes mobile emulation can be driven with behat using the following example:
``` yaml
default:
  extensions:</p>

<pre><code>Behat\MinkExtension: 
  base_url: "http://urltotest.com/"
  default_session: selenium_firefox_session
  goutte: ~
  sessions: 
    goutte_session: 
      goutte: 
        guzzle_parameters: 
          ssl.certificate_authority: false
    selenium_chrome_mobile_session: 
      selenium2: 
        browser: chrome
        capabilities: 
          extra_capabilities: 
            chromeOptions: 
              mobileEmulation: 
                deviceName: "Google Nexus 5"
    selenium_chrome_session: 
      selenium2: 
        browser: chrome
        capabilities: 
          extra_capabilities: 
            chromeOptions: 
              args: 
                - "--start-maximized"
                - "--test-type"
    selenium_firefox_session: 
      selenium2: 
        browser: firefox
</code></pre>

<p>  suites:</p>

<pre><code>my_suite: 
  contexts: 
    - FeatureContext
    - Behat\MinkExtension\Context\MinkContext
</code></pre>

<p>chrome_mobile:
  extensions:</p>

<pre><code>Behat\MinkExtension: 
  default_session: selenium_chrome_mobile_session
</code></pre>

<p>```</p>

<p>With Behat and Mink we are able to pass extra parameters to the chrome selnium driver using the extra_capabilities options. In the above example we enable mobile emulation using the &ldquo;Google Nexus 5&rdquo; profile. To drive tests using this we have two options.</p>

<p>Specify the profile at run time using:
<code>bash
bin/behat -p chrome
</code></p>

<p>Alternative you can tag specific scenarios to use a given profile by using the following tag above the scenario you want to affect:
<code>bash
@mink:selenium_chrome_mobile_session
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiple Behat and Mink profiles for testing multiple browsers]]></title>
    <link href="http://edmondscommerce.github.io/Behat/multiple-behat-and-mink-profiles-for-testing-multiple-browsers.html"/>
    <updated>2015-02-03T12:20:36+00:00</updated>
    <id>http://edmondscommerce.github.io/Behat/multiple-behat-and-mink-profiles-for-testing-multiple-browsers</id>
    <content type="html"><![CDATA[<p>Behat makes it easy to write and run automated testing in browser and in most cases where functionality is not javascript driven then testing in a single browser is fine.</p>

<p>However if you are testing Javascript driven functionality then it is best to have multiple profiles for multiple browsers without having to write the scenario multiple times with different tagsi for different sessions. Luckily behat support defination of multiple profiles which inherit from a single default profile for all your browser needs. You simply need to set up your bhat yaml config file like so:
``` yaml
default:
  extensions:</p>

<pre><code>Behat\MinkExtension: 
  base_url: "http://someurl.com"
  default_session: selenium_firefox_session
  goutte: ~
  sessions: 
    goutte_session: 
      goutte: 
        guzzle_parameters: 
          ssl.certificate_authority: false
    selenium_chrome_session: 
      selenium2: 
        browser: chrome
    selenium_firefox_session: 
      selenium2: 
        browser: firefox
</code></pre>

<p>  suites:</p>

<pre><code>my_suite: 
  contexts: 
    - FeatureContext
    - Behat\MinkExtension\Context\MinkContext
</code></pre>

<p>chrome:
  extensions:</p>

<pre><code>Behat\MinkExtension: 
  default_session: selenium_chrome_session
</code></pre>

<p>firefox:
  extensions:</p>

<pre><code>Behat\MinkExtension: 
  default_session: selenium_firefox_session
</code></pre>

<p>```</p>

<p>The to run the crome profile for example use the -p option flag on the behat command as show:
<code>bash
bin/behat -p chrome
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Apache JMeter For Load Testing]]></title>
    <link href="http://edmondscommerce.github.io/load%20testing/using-apache-jmeter-for-load-testing.html"/>
    <updated>2014-05-27T13:01:39+01:00</updated>
    <id>http://edmondscommerce.github.io/load%20testing/using-apache-jmeter-for-load-testing</id>
    <content type="html"><![CDATA[<p>Load testing is something that you really need a decent solution for. A simple tool such as Apache Bench (ab) is overly simplistic for todays web applications.</p>

<p>After some research I decided to use Apache Jmeter as the tool of choice. It is written in Java so easy enough to run on any platform.
It features a GUI which is ideal for creating your tests, then a command line version which is what you should use to run your tests.</p>

<p>For my purposes I wanted to feed in a large list of URLs, for that I followed these instructions:
<a href="http://asciiville.com/musings/coder/how-to-feed-jmeter-from-csv">http://asciiville.com/musings/coder/how-to-feed-jmeter-from-csv</a></p>

<p>This allows you to create a csv file with your choice of URLs. It was actually quite hard to find a decent and succint guide to getting this set up but thankfully that page fitted my requirements.</p>

<p>Once I started to run the test I quickly realised that my system was grinding to a halt with out of memory errors. A bit more searching yielded this page which advises on how to properly run Jmeter including the fact that you really should run it on the command line for proper testing.
<a href="http://blazemeter.com/blog/jmeter-performance-and-tuning-tips">http://blazemeter.com/blog/jmeter-performance-and-tuning-tips</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How To Prototype For Mobile Devices Fast & Easy?]]></title>
    <link href="http://edmondscommerce.github.io/web%20design/how-to-prototype-for-mobile-devices-fast-easy.html"/>
    <updated>2013-07-29T11:29:32+01:00</updated>
    <id>http://edmondscommerce.github.io/web%20design/how-to-prototype-for-mobile-devices-fast-easy</id>
    <content type="html"><![CDATA[<p><img src="/assets/ProtoIO.png"></p>

<p>As a designer who is keen on usability and user centric, well tested web systems I was in a desperate need of silly fast and useful mobile prototyping system. Up until recently I’ve used paper prototyping and later uploading images on various smart phones (always struggling with inaccurate representation of actual interface size, look and feel of the interactions).</p>

<p>Thankfully, that is the past and the future holds much brighter and functional solution for <a href="https://proto.io/" title="Proto.io - Rapid fast mobile prototyping" target="_blank">rapid fast mobile prototyping thanks to Proto.io </a></p>

<p>I see that they have been around for a while, which only brings lots of benefits to us – usability testers and designers. Prototyping application interface is improved and it has some really good functionality, although there is still room to grow like to support keyboard commands, more tutorials and find a way of making the overall work flow more intuitive as I found it hard to get into. Thankfully, proto.io team has created video tutorials for some of the most important questions.</p>

<p>Once I got the basic idea and figured out some work-arounds, I was able to upload my mobile site design in the application and create a working prototype. It is awesome, how fast and easy it is to test the prototypes on various devices. The most important feature I found is that I can access the fully working prototype from whatever device.</p>
]]></content>
  </entry>
  
</feed>
